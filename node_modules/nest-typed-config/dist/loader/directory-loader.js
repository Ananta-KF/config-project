"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.directoryLoader = void 0;
const fs_1 = require("fs");
const file_loader_1 = require("./file-loader");
const lodash_frompairs_1 = __importDefault(require("lodash.frompairs"));
/**
 * Directory loader loads configuration in a specific folder.
 * The basename of file will be used as configuration key, for the directory below:
 *
 * ```
 * .
 * └─config
 *    ├── app.toml
 *    └── db.toml
 * ```
 *
 * The parsed config will be `{ app: "config in app.toml", db: "config in db.toml" }`
 * @param options directory loader options.
 */
const directoryLoader = (_a) => {
    var { directory } = _a, options = __rest(_a, ["directory"]);
    return () => {
        const files = (0, fs_1.readdirSync)(directory).filter(fileName => options.include ? options.include.test(fileName) : true);
        const fileNames = [
            ...new Set(files.map(file => file.replace(/\.\w+$/, ''))),
        ];
        const configs = (0, lodash_frompairs_1.default)(fileNames.map(name => [
            name,
            (0, file_loader_1.fileLoader)(Object.assign({ basename: name, searchFrom: directory }, options))(),
        ]));
        return configs;
    };
};
exports.directoryLoader = directoryLoader;
//# sourceMappingURL=directory-loader.js.map