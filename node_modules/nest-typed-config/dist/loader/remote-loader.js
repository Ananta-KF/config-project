"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.remoteLoader = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const identity_util_1 = require("../utils/identity.util");
const load_package_util_1 = require("../utils/load-package.util");
let parseJson;
let parseYaml;
let parseToml;
let HttpService;
let axios;
/**
 * Async loader loads configuration at remote endpoint.
 *
 * @param url Remote location of configuration
 * @param options options to configure async loader, support all `axios` options
 */
const remoteLoader = (url, options = {}) => {
    HttpService = (0, load_package_util_1.loadPackage)('@nestjs/axios', 'remoteLoader').HttpService;
    axios = (0, load_package_util_1.loadPackage)('axios', 'remoteLoader');
    return () => __awaiter(void 0, void 0, void 0, function* () {
        const { mapResponse = identity_util_1.identity, type, shouldRetry = () => false, retryInterval = 3000, retries = 3, } = options;
        const httpService = new HttpService(axios.create());
        const config = yield (0, rxjs_1.lastValueFrom)(httpService
            .request(Object.assign({ url }, options))
            .pipe((0, operators_1.map)(response => {
            if (shouldRetry(response)) {
                throw new Error(`Error when fetching config, response.data: ${JSON.stringify(response.data)}`);
            }
            return mapResponse(response.data);
        }), (0, operators_1.retryWhen)(errors => {
            let retryCount = 0;
            return errors.pipe((0, operators_1.delay)(retryInterval), (0, operators_1.map)(error => {
                if (retryCount >= retries) {
                    throw new Error(`Fetch config with remote-loader failed, as the number of retries has been exhausted. ${error.message}`);
                }
                retryCount += 1;
                return error;
            }), (0, operators_1.take)(retries + 1));
        })));
        const parser = {
            json: (content) => {
                parseJson = (0, load_package_util_1.loadPackage)('parse-json', "remoteLoader's ability to parse JSON files");
                return parseJson(content);
            },
            yaml: (content) => {
                parseYaml = (0, load_package_util_1.loadPackage)('yaml', "remoteLoader's ability to parse YAML files").parse;
                return parseYaml(content);
            },
            yml: (content) => {
                parseYaml = (0, load_package_util_1.loadPackage)('yaml', "remoteLoader's ability to parse YML files").parse;
                return parseYaml(content);
            },
            toml: (content) => {
                parseToml = (0, load_package_util_1.loadPackage)('@iarna/toml', "remoteLoader's ability to parse TOML files").parse;
                return parseToml(content);
            },
        };
        const realType = typeof type === 'function' ? type(config) : type;
        if (typeof config === 'string' && realType && parser[realType]) {
            return parser[realType](config);
        }
        return config;
    });
};
exports.remoteLoader = remoteLoader;
//# sourceMappingURL=remote-loader.js.map