"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var TypedConfigModule_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedConfigModule = void 0;
const common_1 = require("@nestjs/common");
const chalk_1 = require("chalk");
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const for_each_deep_util_1 = require("./utils/for-each-deep.util");
const identity_util_1 = require("./utils/identity.util");
const debug_util_1 = require("./utils/debug.util");
const imports_util_1 = require("./utils/imports.util");
let TypedConfigModule = TypedConfigModule_1 = class TypedConfigModule {
    static forRoot(options) {
        const rawConfig = this.getRawConfig(options.load);
        return this.getDynamicModule(options, rawConfig);
    }
    static forRootAsync(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const rawConfig = yield this.getRawConfigAsync(options.load);
            return this.getDynamicModule(options, rawConfig);
        });
    }
    static getDynamicModule(options, rawConfig) {
        const { schema: Config, normalize = identity_util_1.identity, validationOptions, isGlobal = true, validate = this.validateWithClassValidator.bind(this), } = options;
        if (typeof rawConfig !== 'object') {
            throw new Error(`Configuration should be an object, received: ${rawConfig}. Please check the return value of \`load()\``);
        }
        const normalized = normalize(rawConfig);
        const config = validate(normalized, Config, validationOptions);
        const providers = this.getProviders(config, Config);
        return {
            global: isGlobal,
            module: TypedConfigModule_1,
            providers,
            exports: providers,
        };
    }
    static getRawConfig(load) {
        if (Array.isArray(load)) {
            const config = {};
            for (const fn of load) {
                // we shouldn't silently catch errors here, because app shouldn't start without the proper config
                // same way as it doesn't start without the proper database connection
                // and the same way as it now fail for the single loader
                try {
                    const conf = fn(config);
                    (0, lodash_merge_1.default)(config, conf);
                }
                catch (e) {
                    (0, debug_util_1.debug)(`Config load failed: ${e}. Details: ${JSON.stringify(e.details)}`);
                    throw e;
                }
            }
            return config;
        }
        return load();
    }
    static getRawConfigAsync(load) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Array.isArray(load)) {
                const config = {};
                for (const fn of load) {
                    try {
                        const conf = yield fn(config);
                        (0, lodash_merge_1.default)(config, conf);
                    }
                    catch (e) {
                        (0, debug_util_1.debug)(`Config load failed: ${e}. Details: ${JSON.stringify(e.details)}`);
                        throw e;
                    }
                }
                return config;
            }
            return load();
        });
    }
    static getProviders(config, Config) {
        const providers = [
            {
                provide: Config,
                useValue: config,
            },
        ];
        (0, for_each_deep_util_1.forEachDeep)(config, value => {
            if (value &&
                typeof value === 'object' &&
                !Array.isArray(value) &&
                value.constructor !== Object) {
                providers.push({ provide: value.constructor, useValue: value });
            }
        });
        return providers;
    }
    static validateWithClassValidator(rawConfig, Config, options) {
        const config = (0, imports_util_1.plainToClass)(Config, rawConfig, {
            exposeDefaultValues: true,
        });
        // defaults to strictest validation rules
        const schemaErrors = (0, imports_util_1.validateSync)(config, Object.assign({ forbidUnknownValues: true, whitelist: true }, options));
        if (schemaErrors.length > 0) {
            const configErrorMessage = this.getConfigErrorMessage(schemaErrors);
            throw new Error(configErrorMessage);
        }
        return config;
    }
    static getConfigErrorMessage(errors) {
        const messages = this.formatValidationError(errors)
            .map(({ property, value, constraints }) => {
            const constraintMessage = Object.entries(constraints || /* istanbul ignore next */ {})
                .map(([key, val]) => `    - ${key}: ${(0, chalk_1.yellow)(val)}, current config is \`${(0, chalk_1.blue)(JSON.stringify(value))}\``)
                .join(`\n`);
            const msg = [
                `  - config ${(0, chalk_1.cyan)(property)} does not match the following rules:`,
                `${constraintMessage}`,
            ].join(`\n`);
            return msg;
        })
            .filter(Boolean)
            .join(`\n`);
        const configErrorMessage = (0, chalk_1.red)(`Configuration is not valid:\n${messages}\n`);
        return configErrorMessage;
    }
    /**
     * Transforms validation error object returned by class-validator to more
     * readable error messages.
     */
    static formatValidationError(errors) {
        const result = [];
        const helper = ({ property, constraints, children, value }, prefix) => {
            const keyPath = prefix ? `${prefix}.${property}` : property;
            if (constraints) {
                result.push({
                    property: keyPath,
                    constraints,
                    value,
                });
            }
            if (children && children.length) {
                children.forEach(child => helper(child, keyPath));
            }
        };
        errors.forEach(error => helper(error, ``));
        return result;
    }
};
exports.TypedConfigModule = TypedConfigModule;
exports.TypedConfigModule = TypedConfigModule = TypedConfigModule_1 = __decorate([
    (0, common_1.Module)({})
], TypedConfigModule);
//# sourceMappingURL=typed-config.module.js.map